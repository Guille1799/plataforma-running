"""
Garmin Connect integration service.
Handles authentication, activity fetching, and FIT file parsing.
"""

import io
import json
import zipfile
import tempfile
import os
import logging
from pathlib import Path
from datetime import datetime, date, timedelta
from typing import List, Dict, Optional
import fitparse
from garminconnect import Garmin as GarminConnectAPI
import garth
from sqlalchemy.orm import Session
from cryptography.fernet import Fernet

from .. import models, crud
from ..core.config import settings


# Encryption key (should be in settings)
# Generate a Fernet-compatible key from secret_key
import base64
import hashlib

# Create a 32-byte key from settings.secret_key using SHA-256
key_bytes = hashlib.sha256(settings.secret_key.encode()).digest()
# Fernet requires base64-encoded 32-byte key
ENCRYPTION_KEY = base64.urlsafe_b64encode(key_bytes)
cipher = Fernet(ENCRYPTION_KEY)

# Global cache for garth sessions (in-memory, per-process)
# Key: (user_id, token_hash), Value: (api_instance, timestamp)
_garth_session_cache: Dict[tuple, tuple] = {}


def encrypt_token(token: str) -> str:
    """Encrypt Garmin token for secure storage."""
    return cipher.encrypt(token.encode()).decode()


def decrypt_token(encrypted_token: str) -> str:
    """Decrypt Garmin token from database."""
    return cipher.decrypt(encrypted_token.encode()).decode()


def authenticate_garmin(email: str, password: str) -> Dict[str, any]:
    """
    Authenticate with Garmin Connect and return session token.

    Args:
        email: Garmin Connect email
        password: Garmin Connect password

    Returns:
        Dict with serialized garth session and user info

    Raises:
        Exception: If authentication fails
    """
    # Login with garth (handles OAuth flow)
    garth.login(email, password)

    # Configure garth client
    garth.configure(domain="garmin.com")

    # Use temporary directory for initial login (to get user_id after)
    temp_dir = tempfile.mkdtemp()
    garth.save(temp_dir)

    # Read ONLY OAuth token files (ignore email/password for security)
    session_data = {}
    allowed_files = ["oauth1_token.json", "oauth2_token.json"]
    for filename in os.listdir(temp_dir):
        if filename in allowed_files:
            file_path = os.path.join(temp_dir, filename)
            with open(file_path, "r") as f:
                session_data[filename] = f.read()

    # Clean up temp directory (session will be stored in DB and persistent dir)
    import shutil

    shutil.rmtree(temp_dir)

    if not session_data:
        raise Exception("No session files generated by garth")

    # Configure garth with longer timeout for large syncs (2 years of data)
    garth.configure(timeout=120)

    # Initialize Garmin API (uses garth's global client)
    api = GarminConnectAPI()

    # Verify connection
    user_info = api.get_full_name()

    return {
        "session_data": json.dumps(session_data),  # All garth session files as JSON
        "api": api,
        "user_name": user_info,
    }


def connect_user_garmin(
    db: Session, user_id: int, email: str, password: str
) -> models.User:
    """
    Connect a user's Garmin account.
    Stores encrypted email + password for re-authentication.

    Args:
        db: Database session
        user_id: User ID
        email: Garmin email
        password: Garmin password

    Returns:
        Updated User model
    """
    # Note: We don't verify credentials here to avoid blocking on Garmin's OAuth
    # Verification happens during first sync when we actually need the connection
    print(f"[GARMIN] Storing credentials for {email}")

    # Store email + encrypted password (most reliable for garth re-auth)
    credentials = json.dumps({"email": email, "password": password})
    encrypted_credentials = encrypt_token(credentials)

    # Update user
    user = crud.get_user_by_id(db, user_id)
    user.garmin_email = email
    user.garmin_token = encrypted_credentials
    user.garmin_connected_at = datetime.utcnow()

    db.commit()
    db.refresh(user)

    print(f"[GARMIN] Credentials stored for user {user_id}")
    return user


def get_user_garmin_api(db: Session, user_id: int) -> GarminConnectAPI:
    """
    Get authenticated Garmin API for a user.
    Creates Garmin instance and calls .login() explicitly.

    Args:
        db: Database session
        user_id: User ID

    Returns:
        Authenticated GarminConnectAPI instance

    Raises:
        Exception: If user not connected or credentials invalid
    """
    user = crud.get_user_by_id(db, user_id)

    if not user.garmin_token or not user.garmin_email:
        raise Exception("User has not connected Garmin account")

    # Decrypt credentials
    credentials_json = decrypt_token(user.garmin_token)
    credentials = json.loads(credentials_json)

    email = credentials["email"]
    password = credentials["password"]

    print(f"[GARMIN] Creating Garmin() with credentials")

    # Configure garth with longer timeout for large syncs (2 years of data)
    garth.configure(timeout=120)

    # Use garth directly to ensure session is saved correctly
    print(f"[GARMIN] Logging in with garth...")
    garth.login(email, password)
    garth.configure(domain="garmin.com")

    print(f"[GARMIN] Login successful")

    # Save OAuth tokens to persistent directory for Celery workers
    persistent_dir = "/app/garmin_tokens"
    user_token_dir = os.path.join(persistent_dir, f"user_{user_id}")
    os.makedirs(user_token_dir, exist_ok=True)

    # Save garth session directly to user's persistent directory
    print(f"[GARMIN] Saving session to {user_token_dir}")
    garth.save(user_token_dir)

    # Remove email/password files for security (keep only OAuth tokens)
    import shutil

    allowed_files = ["oauth1_token.json", "oauth2_token.json"]
    for filename in os.listdir(user_token_dir):
        if filename not in allowed_files:
            file_path = os.path.join(user_token_dir, filename)
            os.remove(file_path)
            print(f"[GARMIN] Removed {filename} for security")
        else:
            # Verify file has content
            file_path = os.path.join(user_token_dir, filename)
            size = os.path.getsize(file_path)
            print(f"[GARMIN] Kept {filename} ({size} bytes)")

    # Now create GarminConnectAPI using the authenticated garth session
    api = GarminConnectAPI()

    return api


def parse_fit_file(fit_data: bytes, activity_id: str) -> Dict[str, any]:
    """
    Parse FIT file and extract metrics (adapted from your script).

    Args:
        fit_data: Raw FIT file bytes
        activity_id: Activity ID for reference

    Returns:
        Dict with extracted metrics
    """
    fitfile = fitparse.FitFile(io.BytesIO(fit_data))

    # --- Data Extraction from FIT file ---

    # The 'session' message contains aggregated data for the entire workout.
    # This is much more efficient than iterating through every 'record' message.
    session_data = {}
    for record in fitfile.get_messages("session"):
        session_data = {field.name: field.value for field in record}
        break  # There should only be one session message

    if not session_data:
        # Fallback if no session data is found
        return {"sport_type": "unknown"}

    # --- Map Session Data to our Schema ---

    # Cadence: Garmin reports "strides per minute" (one leg). We want "steps per minute" (both legs).
    # So, we multiply by 2.
    avg_cadence_spm = session_data.get("avg_running_cadence")
    avg_cadence = int(avg_cadence_spm * 2) if avg_cadence_spm else None

    max_cadence_spm = session_data.get("max_running_cadence")
    max_cadence = int(max_cadence_spm * 2) if max_cadence_spm else None

    # Vertical Oscillation (in mm, we convert to cm)
    avg_vo_mm = session_data.get("avg_vertical_oscillation")
    avg_vertical_oscillation = round(avg_vo_mm / 10, 2) if avg_vo_mm else None

    # Stance Time (in ms)
    avg_stance_time = (
        round(session_data.get("avg_stance_time"), 1)
        if session_data.get("avg_stance_time")
        else None
    )

    # Stride Length (in mm, we convert to m)
    avg_stride_length_mm = session_data.get("avg_step_length")
    avg_stride_length = (
        round(avg_stride_length_mm / 1000, 2) if avg_stride_length_mm else None
    )

    # Leg Spring Stiffness (kN/m)
    avg_leg_spring_stiffness = session_data.get("avg_leg_spring_stiffness")

    # Ground Contact Time Balance (as a percentage, left foot)
    # Try multiple field names as Garmin uses different names across devices
    avg_gct_balance = (
        session_data.get("avg_stance_time_percent_left")
        or session_data.get("stance_time_balance")
        or session_data.get("avg_left_torso_angle")
        or None
    )
    # If we have balance, ensure it's in the 0-100 range
    if avg_gct_balance and avg_gct_balance > 1:
        avg_gct_balance = avg_gct_balance  # Already percentage
    elif avg_gct_balance:
        avg_gct_balance = avg_gct_balance * 100  # Convert decimal to percentage

    # --- Detailed Records for Charts ---
    # We still iterate through records to get timeseries data for charts.
    records = []
    record_fields = [
        "timestamp",
        "heart_rate",
        "power",
        "enhanced_altitude",
        "distance",
        "speed",
    ]
    for record in fitfile.get_messages("record"):
        data = {
            field.name: field.value for field in record if field.name in record_fields
        }
        if "timestamp" in data and data["timestamp"]:
            records.append(data)

    # --- Final Data Structure ---
    return {
        "sport_type": session_data.get("sport", "running"),
        "start_time": session_data.get("start_time"),
        "duration_seconds": int(session_data.get("total_timer_time", 0)),
        "distance_meters": round(session_data.get("total_distance", 0.0), 2),
        "avg_pace": (
            session_data.get("total_timer_time", 0)
            / (session_data.get("total_distance", 1) / 1000)
            if session_data.get("total_distance")
            else None
        ),
        "avg_heart_rate": session_data.get("avg_heart_rate"),
        "max_heart_rate": session_data.get("max_heart_rate"),
        "avg_power": session_data.get("avg_power"),
        "elevation_gain": session_data.get("total_ascent"),
        # Running Dynamics
        "avg_cadence": avg_cadence,
        "max_cadence": max_cadence,
        "avg_vertical_oscillation": avg_vertical_oscillation,
        "avg_stance_time": avg_stance_time,
        "avg_stride_length": avg_stride_length,
        "avg_leg_spring_stiffness": avg_leg_spring_stiffness,
        "left_right_balance": avg_gct_balance,
        # Timeseries data for charts
        "records": records,
    }


def sync_user_zones_and_profile(
    db: Session, user_id: int, api: GarminConnectAPI
) -> None:
    """
    Sync HR zones, power zones, and athlete profile data from Garmin.

    Args:
        db: Database session
        user_id: User ID
        api: Authenticated Garmin API instance
    """
    try:
        user = crud.get_user_by_id(db, user_id)

        # Get user profile (height, weight, etc)
        print("[ZONES] Fetching user profile...")
        try:
            profile_data = api.get_user_profile()
            print(
                f"[ZONES] User profile data keys: {list(profile_data.keys()) if profile_data else 'None'}"
            )

            # Log full userData for debugging
            if profile_data and "userData" in profile_data:
                print(
                    f"[ZONES] Full userData keys: {list(profile_data['userData'].keys())}"
                )
                print(
                    f"[ZONES] Sample userData (first 15 fields): {dict(list(profile_data['userData'].items())[:15])}"
                )

            # Update user profile with Garmin data
            # The actual data is nested in 'userData'
            if profile_data and "userData" in profile_data:
                user_data = profile_data["userData"]

                # Height in cm
                if "height" in user_data and user_data["height"]:
                    user.height_cm = user_data["height"]
                    print(f"[ZONES] Updated height: {user.height_cm} cm")

                # Weight in kg (Garmin returns weight in grams)
                if "weight" in user_data and user_data["weight"]:
                    user.weight_kg = user_data["weight"] / 1000
                    print(f"[ZONES] Updated weight: {user.weight_kg} kg")

                # Date of birth
                if "birthDate" in user_data and user_data["birthDate"]:
                    try:
                        from datetime import datetime

                        user.birth_date = datetime.strptime(
                            user_data["birthDate"], "%Y-%m-%d"
                        ).date()
                        print(f"[ZONES] Updated birth date: {user.birth_date}")
                    except:
                        pass

                # Gender
                if "gender" in user_data and user_data["gender"]:
                    user.gender = user_data["gender"].lower()
                    print(f"[ZONES] Updated gender: {user.gender}")

                # VO2 Max Running
                if "vo2MaxRunning" in user_data and user_data["vo2MaxRunning"]:
                    user.vo2_max = user_data["vo2MaxRunning"]
                    print(f"[ZONES] Updated VO2 Max: {user.vo2_max} ml/kg/min")

                # Lactate Threshold HR (can be used as a proxy for threshold HR)
                if (
                    "lactateThresholdHeartRate" in user_data
                    and user_data["lactateThresholdHeartRate"]
                ):
                    # This is actually a good estimate for max HR in many cases
                    # Store it but don't overwrite if user has a custom max HR
                    if not user.max_heart_rate:
                        user.max_heart_rate = user_data["lactateThresholdHeartRate"]
                        print(
                            f"[ZONES] Updated max HR from lactate threshold: {user.max_heart_rate} bpm"
                        )

                db.commit()
                print("[ZONES] User profile basic data updated successfully")
        except Exception as e:
            print(f"[ZONES] Could not fetch user profile: {e}")
            import traceback

            traceback.print_exc()
            profile_data = {}

        # Sync health metrics (HRV, sleep, stress, body battery, etc.)
        print("[ZONES] Syncing health metrics...")
        try:
            from .health_sync_service import (
                sync_health_metrics,
                get_latest_health_metric,
            )
            from .. import models

            # Determine days to sync based on whether we have health metrics
            user = crud.get_user_by_id(db, user_id)

            # Check if user has ANY health metrics from Garmin
            existing_health = (
                db.query(models.HealthMetric)
                .filter(
                    models.HealthMetric.user_id == user_id,
                    models.HealthMetric.source == "garmin",
                )
                .first()
            )

            is_first_health_sync = existing_health is None

            if is_first_health_sync:
                # First sync: get 2 years of health data
                health_days = 730
                print(
                    f"[ZONES] First health sync: pulling {health_days} days of health metrics"
                )
            else:
                # Incremental: just update today and yesterday (data doesn't change beyond that)
                health_days = 2
                print(
                    f"[ZONES] Incremental sync: pulling {health_days} days of health metrics"
                )

            health_metrics = sync_health_metrics(
                api, user_id, db, days_back=health_days
            )

            # Update user's resting HR from most recent health metric
            latest_health = get_latest_health_metric(user_id, db)
            if latest_health and latest_health.resting_hr_bpm:
                user.resting_heart_rate = latest_health.resting_hr_bpm
                print(
                    f"[ZONES] Updated resting HR from health data: {user.resting_heart_rate} bpm"
                )

            db.commit()
            print(f"[ZONES] Health metrics sync completed: {len(health_metrics)} days")
        except Exception as e:
            print(f"[ZONES] Could not sync health metrics: {e}")
            import traceback

            traceback.print_exc()

        # Note: get_user_settings() doesn't exist in garminconnect library
        # All the data we need is already obtained from:
        # - userData for profile (height, weight, VO2 max, lactate threshold HR)
        # - health metrics for resting HR
        # So we skip this section

        # Try to get heart rate zones
        print("[ZONES] Fetching HR zones...")
        hr_zones = []
        try:
            # Calculate based on max HR if available
            if user.max_heart_rate:
                max_hr = user.max_heart_rate
                hr_zones = [
                    {
                        "zone": 1,
                        "name": "Z1",
                        "min": int(max_hr * 0.50),
                        "max": int(max_hr * 0.60),
                    },
                    {
                        "zone": 2,
                        "name": "Z2",
                        "min": int(max_hr * 0.60),
                        "max": int(max_hr * 0.70),
                    },
                    {
                        "zone": 3,
                        "name": "Z3",
                        "min": int(max_hr * 0.70),
                        "max": int(max_hr * 0.80),
                    },
                    {
                        "zone": 4,
                        "name": "Z4",
                        "min": int(max_hr * 0.80),
                        "max": int(max_hr * 0.90),
                    },
                    {
                        "zone": 5,
                        "name": "Z5",
                        "min": int(max_hr * 0.90),
                        "max": int(max_hr * 1.00),
                    },
                ]
                print(f"[ZONES] Calculated HR zones from max HR: {hr_zones}")

            if hr_zones:
                user.hr_zones = hr_zones
                print(f"[ZONES] HR zones saved: {len(hr_zones)} zones")
        except Exception as e:
            print(f"[ZONES] Error fetching HR zones: {e}")

        # Try to get power zones
        print("[ZONES] Fetching power zones...")
        power_zones = []
        try:
            # Power zones are typically trainer/power meter specific
            # Try to fetch from settings
            settings = api.get_user_settings()
            if "powerZones" in settings:
                power_zones = settings["powerZones"]
                print(f"[ZONES] Power zones found: {power_zones}")
        except Exception as e:
            print(f"[ZONES] Power zones not available: {e}")

        if power_zones:
            user.power_zones = power_zones

        db.commit()
        print("[ZONES] Profile sync completed")

    except Exception as e:
        print(f"[ZONES] Error syncing profile: {e}")


def sync_user_activities(
    db: Session,
    user_id: int,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
) -> List[models.Workout]:
    """
    Sync activities from Garmin for a user.

    Args:
        db: Database session
        user_id: User ID
        start_date: Start date for sync (default: last 7 days, or 12 months if first sync)
        end_date: End date for sync (default: today)

    Returns:
        List of created Workout models
    """
    print(f"[SYNC] Starting sync for user {user_id}, dates: {start_date} to {end_date}")

    # Get user to check if first sync
    user = crud.get_user_by_id(db, user_id)
    is_first_sync = user.last_garmin_sync is None

    # Get Garmin API
    print("[SYNC] Calling get_user_garmin_api...")
    api = get_user_garmin_api(db, user_id)
    print("[SYNC] API obtained successfully")

    # Sync user profile, zones, and settings
    sync_user_zones_and_profile(db, user_id, api)

    # Default date range
    if not end_date:
        end_date = date.today()
    if not start_date:
        if is_first_sync:
            # First sync: get last 2 years
            start_date = end_date - timedelta(days=730)
            print(f"[SYNC] First sync detected - pulling 2 years of history")
        else:
            # Subsequent syncs: from last sync date
            if user.last_garmin_sync:
                start_date = user.last_garmin_sync.date()
            else:
                start_date = end_date - timedelta(days=30)
            print(f"[SYNC] Incremental sync from {start_date}")

    # Fetch activities with high limit to get all activities
    # Note: get_activities() is more reliable than get_activities_by_date() which has internal limits
    activities = api.get_activities(start=0, limit=1000)

    # Filter by date range
    activities = [
        act
        for act in activities
        if start_date <= date.fromisoformat(act["startTimeLocal"][:10]) <= end_date
    ]

    print(f"[SYNC] Found {len(activities)} activities from Garmin in date range")

    created_workouts = []
    skipped_count = 0
    max_to_import = 1000  # Safety limit (increased for initial sync)

    for activity_dict in activities:
        # Stop if we reach 1000 workouts
        if len(created_workouts) + skipped_count >= max_to_import:
            print(f"[SYNC] Reached max import limit of {max_to_import}")
            break

        activity_type = activity_dict.get("activityType", {}).get("typeKey", "")

        # Only process running activities
        if "running" not in activity_type.lower():
            skipped_count += 1
            continue

        activity_id = str(activity_dict["activityId"])

        try:
            # Download FIT file
            zip_data = api.download_activity(
                activity_id, dl_fmt=api.ActivityDownloadFormat.ORIGINAL
            )

            # Extract FIT from ZIP
            with zipfile.ZipFile(io.BytesIO(zip_data), "r") as zip_ref:
                fit_filename = [
                    name for name in zip_ref.namelist() if name.endswith(".fit")
                ][0]
                with zip_ref.open(fit_filename) as fit_file:
                    fit_data = fit_file.read()

            # Parse FIT
            workout_data = parse_fit_file(fit_data, activity_id)

            # Log running dynamics data for debugging
            print(
                f"[DEBUG] Parsed workout data - Cadence: {workout_data.get('avg_cadence')}, "
                f"VO: {workout_data.get('avg_vertical_oscillation')}, "
                f"Stance: {workout_data.get('avg_stance_time')}, "
                f"Balance: {workout_data.get('left_right_balance')}"
            )

            # Check if already exists by start_time (more reliable than ID)
            existing = crud.get_workout_by_start_time(
                db, user_id, workout_data["start_time"]
            )
            if existing:
                print(
                    f"[SYNC] Workout at {workout_data['start_time']} already exists, skipping"
                )
                skipped_count += 1
                continue

            # Create workout schema
            from ..schemas import WorkoutCreate

            workout_create = WorkoutCreate(**workout_data)

            # Log what's being passed to the database
            print(
                f"[DEBUG] WorkoutCreate object - Cadence: {workout_create.avg_cadence}, "
                f"VO: {workout_create.avg_vertical_oscillation}"
            )

            # Save to database
            workout = crud.create_workout(db, user_id, workout_create)
            created_workouts.append(workout)

        except Exception as e:
            print(f"Error processing activity {activity_id}: {e}")
            skipped_count += 1
            continue

    # Update last_garmin_sync timestamp
    user.last_garmin_sync = datetime.utcnow()
    db.commit()

    print(
        f"[SYNC] Completed. Created: {len(created_workouts)}, Skipped: {skipped_count}"
    )
    return created_workouts


def sync_garmin_activities(db: Session, user_id: int) -> List[models.Workout]:
    """
    Fetch recent activities from Garmin, parse them, and store them.
    """
    print("[SYNC] Starting sync...")
    try:
        api = get_user_garmin_api(db, user_id)
        print("[SYNC] API obtained successfully")

        # Sync user profile data (HR zones, etc.) first
        sync_user_profile_data(db, user_id, api)

        # Determine date range for fetching activities
        user = crud.get_user_by_id(db, user_id)
        is_first_sync = user.last_garmin_sync is None
        end_date = date.today()

        # First sync: get last 2 years (730 days)
        # Subsequent syncs: get from last sync date (not last workout date!)
        if is_first_sync:
            start_date = end_date - timedelta(days=730)
            print(f"[SYNC] First sync detected - pulling 2 years of history")
        else:
            # Use last_garmin_sync date (when we last checked), not last workout date
            # This ensures we don't miss workouts if user hasn't synced in a while
            if user.last_garmin_sync:
                start_date = user.last_garmin_sync.date()
            else:
                # Fallback: get last 30 days if somehow sync date is missing
                start_date = end_date - timedelta(days=30)
            print(f"[SYNC] Incremental sync from last sync: {start_date}")

        print(f"[SYNC] Fetching activities from {start_date} to {end_date}")

        # Fetch activities with high limit to get all activities
        activities = api.get_activities(start=0, limit=1000)

        # Filter by date range
        activities = [
            act
            for act in activities
            if start_date <= date.fromisoformat(act["startTimeLocal"][:10]) <= end_date
        ]

        print(f"[SYNC] Found {len(activities)} activities from Garmin in date range")

        created_workouts = []
        skipped_count = 0
        max_to_import = 1000  # Safety limit (increased for initial sync)

        for activity_dict in activities:
            # Stop if we reach 1000 workouts
            if len(created_workouts) + skipped_count >= max_to_import:
                print(f"[SYNC] Reached max import limit of {max_to_import}")
                break

            activity_type = activity_dict.get("activityType", {}).get("typeKey", "")

            # Only process running activities
            if "running" not in activity_type.lower():
                skipped_count += 1
                continue

            activity_id = str(activity_dict["activityId"])

            try:
                # Download FIT file
                zip_data = api.download_activity(
                    activity_id, dl_fmt=api.ActivityDownloadFormat.ORIGINAL
                )

                # Extract FIT from ZIP
                with zipfile.ZipFile(io.BytesIO(zip_data), "r") as zip_ref:
                    fit_filename = [
                        name for name in zip_ref.namelist() if name.endswith(".fit")
                    ][0]
                    with zip_ref.open(fit_filename) as fit_file:
                        fit_data = fit_file.read()

                # Parse FIT
                workout_data = parse_fit_file(fit_data, activity_id)

                # Log running dynamics data for debugging
                print(
                    f"[DEBUG] Parsed workout data - Cadence: {workout_data.get('avg_cadence')}, "
                    f"VO: {workout_data.get('avg_vertical_oscillation')}, "
                    f"Stance: {workout_data.get('avg_stance_time')}, "
                    f"Balance: {workout_data.get('left_right_balance')}"
                )

                # Check if already exists by start_time (more reliable than ID)
                existing = crud.get_workout_by_start_time(
                    db, user_id, workout_data["start_time"]
                )
                if existing:
                    print(
                        f"[SYNC] Workout at {workout_data['start_time']} already exists, skipping"
                    )
                    skipped_count += 1
                    continue

                # Create workout schema
                from ..schemas import WorkoutCreate

                workout_create = WorkoutCreate(**workout_data)

                # Log what's being passed to the database
                print(
                    f"[DEBUG] WorkoutCreate object - Cadence: {workout_create.avg_cadence}, "
                    f"VO: {workout_create.avg_vertical_oscillation}"
                )

                # Save to database
                workout = crud.create_workout(db, user_id, workout_create)
                created_workouts.append(workout)

            except Exception as e:
                print(f"Error processing activity {activity_id}: {e}")
                skipped_count += 1
                continue

        # Update last_garmin_sync timestamp
        user.last_garmin_sync = datetime.utcnow()
        db.commit()

        print(
            f"[SYNC] Completed. Created: {len(created_workouts)}, Skipped: {skipped_count}"
        )
        return created_workouts
    except Exception as e:
        print(f"[SYNC] Error during sync: {e}")
        return []
