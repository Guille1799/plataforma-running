"""
Garmin Connect integration service.
Handles authentication, activity fetching, and FIT file parsing.
"""
import io
import json
import zipfile
import tempfile
import os
from pathlib import Path
from datetime import datetime, date, timedelta
from typing import List, Dict, Optional
import fitparse
from garminconnect import Garmin as GarminConnectAPI
import garth
from sqlalchemy.orm import Session
from cryptography.fernet import Fernet

from .. import models, crud
from ..core.config import settings


# Encryption key (should be in settings)
# TODO: Move to .env
ENCRYPTION_KEY = settings.secret_key[:32].ljust(32, '0').encode()
cipher = Fernet(Fernet.generate_key())  # Will use proper key from settings

# Global cache for garth sessions (in-memory, per-process)
# Key: (user_id, token_hash), Value: (api_instance, timestamp)
_garth_session_cache: Dict[tuple, tuple] = {}


def encrypt_token(token: str) -> str:
    """Encrypt Garmin token for secure storage."""
    return cipher.encrypt(token.encode()).decode()


def decrypt_token(encrypted_token: str) -> str:
    """Decrypt Garmin token from database."""
    return cipher.decrypt(encrypted_token.encode()).decode()


def authenticate_garmin(email: str, password: str) -> Dict[str, any]:
    """
    Authenticate with Garmin Connect and return session token.
    
    Args:
        email: Garmin Connect email
        password: Garmin Connect password
        
    Returns:
        Dict with serialized garth session and user info
        
    Raises:
        Exception: If authentication fails
    """
    # Login with garth (handles OAuth flow)
    garth.login(email, password)
    
    # Configure garth client
    garth.configure(domain="garmin.com")
    
    # Save garth session to temporary directory
    temp_dir = tempfile.mkdtemp()
    garth.save(temp_dir)
    
    # Read session files (garth generates oauth1_token.json and oauth2_token.json)
    session_data = {}
    for filename in os.listdir(temp_dir):
        file_path = os.path.join(temp_dir, filename)
        with open(file_path, 'r') as f:
            session_data[filename] = f.read()
    
    # Clean up temp directory
    import shutil
    shutil.rmtree(temp_dir)
    
    if not session_data:
        raise Exception("No session files generated by garth")
    
    # Initialize Garmin API (uses garth's global client)
    api = GarminConnectAPI()
    
    # Verify connection
    user_info = api.get_full_name()
    
    return {
        'session_data': json.dumps(session_data),  # All garth session files as JSON
        'api': api,
        'user_name': user_info
    }


def connect_user_garmin(
    db: Session,
    user_id: int,
    email: str,
    password: str
) -> models.User:
    """
    Connect a user's Garmin account.
    Stores encrypted email + password for re-authentication.
    
    Args:
        db: Database session
        user_id: User ID
        email: Garmin email
        password: Garmin password
        
    Returns:
        Updated User model
    """
    # Note: We don't verify credentials here to avoid blocking on Garmin's OAuth
    # Verification happens during first sync when we actually need the connection
    print(f"[GARMIN] Storing credentials for {email}")
    
    # Store email + encrypted password (most reliable for garth re-auth)
    credentials = json.dumps({'email': email, 'password': password})
    encrypted_credentials = encrypt_token(credentials)
    
    # Update user
    user = crud.get_user_by_id(db, user_id)
    user.garmin_email = email
    user.garmin_token = encrypted_credentials
    user.garmin_connected_at = datetime.utcnow()
    
    db.commit()
    db.refresh(user)
    
    print(f"[GARMIN] Credentials stored for user {user_id}")
    return user


def get_user_garmin_api(db: Session, user_id: int) -> GarminConnectAPI:
    """
    Get authenticated Garmin API for a user.
    Creates Garmin instance and calls .login() explicitly.
    
    Args:
        db: Database session
        user_id: User ID
        
    Returns:
        Authenticated GarminConnectAPI instance
        
    Raises:
        Exception: If user not connected or credentials invalid
    """
    user = crud.get_user_by_id(db, user_id)
    
    if not user.garmin_token or not user.garmin_email:
        raise Exception("User has not connected Garmin account")
    
    # Decrypt credentials
    credentials_json = decrypt_token(user.garmin_token)
    credentials = json.loads(credentials_json)
    
    email = credentials['email']
    password = credentials['password']
    
    print(f"[GARMIN] Creating Garmin() with credentials")
    
    # Create Garmin instance with credentials
    api = GarminConnectAPI(email=email, password=password)
    
    # MUST call .login() to authenticate
    print(f"[GARMIN] Calling api.login()...")
    api.login()
    
    print(f"[GARMIN] Login successful")
    
    return api


def parse_fit_file(fit_data: bytes, activity_id: str) -> Dict[str, any]:
    """
    Parse FIT file and extract metrics (adapted from your script).
    
    Args:
        fit_data: Raw FIT file bytes
        activity_id: Activity ID for reference
        
    Returns:
        Dict with extracted metrics
    """
    fitfile = fitparse.FitFile(io.BytesIO(fit_data))
    
    # Selected fields (from your script + new running form metrics)
    fields = [
        'timestamp', 'heart_rate', 'cadence', 'power',
        'vertical_oscillation', 'stance_time', 'stride_length',
        'stance_time_balance', 'temperature', 'enhanced_altitude', 'distance',
        'leg_spring_stiffness'
    ]
    
    # Extract records
    records = []
    for record in fitfile.get_messages('record'):
        data = {field.name: field.value for field in record if field.name in fields}
        if 'timestamp' in data and data['timestamp']:
            records.append(data)
    
    if not records:
        return {
            'sport_type': 'running',
            'start_time': datetime.utcnow(),
            'duration_seconds': 0,
            'distance_meters': 0.0
        }
    
    # Calculate aggregates
    start_time = records[0]['timestamp']
    end_time = records[-1]['timestamp']
    duration_seconds = int((end_time - start_time).total_seconds())
    
    # Heart rate metrics
    hr_values = [r['heart_rate'] for r in records if 'heart_rate' in r and r['heart_rate']]
    avg_heart_rate = int(sum(hr_values) / len(hr_values)) if hr_values else None
    max_heart_rate = max(hr_values) if hr_values else None
    
    # Distance
    distances = [r['distance'] for r in records if 'distance' in r and r['distance']]
    distance_meters = max(distances) if distances else 0.0
    
    # Pace (segundos/km)
    avg_pace = duration_seconds / (distance_meters / 1000) if distance_meters > 0 else None
    
    # Power
    power_values = [r['power'] for r in records if 'power' in r and r['power']]
    avg_power = int(sum(power_values) / len(power_values)) if power_values else None
    
    # Altitude
    altitude_values = [r.get('enhanced_altitude', r.get('altitude')) for r in records]
    altitude_values = [a for a in altitude_values if a is not None]
    
    # Calculate elevation gain with GPS noise filtering
    # Threshold: 1 meter (filters GPS variance while preserving real elevation changes)
    elevation_gain = 0.0
    elevation_threshold = 1.0  # meters - filters GPS noise
    if altitude_values:
        for i in range(1, len(altitude_values)):
            diff = altitude_values[i] - altitude_values[i-1]
            if diff > elevation_threshold:
                elevation_gain += diff
    
    # Running Form Metrics
    # Cadence (steps per minute)
    cadence_values = [r['cadence'] for r in records if 'cadence' in r and r['cadence']]
    avg_cadence = sum(cadence_values) / len(cadence_values) if cadence_values else None
    max_cadence = max(cadence_values) if cadence_values else None
    
    # Stance Time (milliseconds, ground contact time)
    stance_time_values = [r['stance_time'] for r in records if 'stance_time' in r and r['stance_time']]
    avg_stance_time = sum(stance_time_values) / len(stance_time_values) if stance_time_values else None
    
    # Vertical Oscillation (centimeters, vertical bounce)
    vertical_osc_values = [r['vertical_oscillation'] for r in records if 'vertical_oscillation' in r and r['vertical_oscillation']]
    avg_vertical_oscillation = sum(vertical_osc_values) / len(vertical_osc_values) if vertical_osc_values else None
    
    # Leg Spring Stiffness (running economy metric)
    stiffness_values = [r['leg_spring_stiffness'] for r in records if 'leg_spring_stiffness' in r and r['leg_spring_stiffness']]
    avg_leg_spring_stiffness = sum(stiffness_values) / len(stiffness_values) if stiffness_values else None
    
    # Left/Right Balance (percentage, 50 = balanced)
    balance_values = [r['stance_time_balance'] for r in records if 'stance_time_balance' in r and r['stance_time_balance']]
    # stance_time_balance is typically 0-100, where 50 = 50/50 balance
    left_right_balance = sum(balance_values) / len(balance_values) if balance_values else 50.0
    
    return {
        'sport_type': 'running',
        'start_time': start_time,
        'duration_seconds': duration_seconds,
        'distance_meters': distance_meters,
        'avg_heart_rate': avg_heart_rate,
        'max_heart_rate': max_heart_rate,
        'avg_pace': avg_pace,
        'max_speed': None,  # TODO: Calculate from records
        'calories': None,  # TODO: Extract from FIT
        'elevation_gain': elevation_gain,
        'avg_cadence': avg_cadence,
        'max_cadence': max_cadence,
        'avg_stance_time': avg_stance_time,
        'avg_vertical_oscillation': avg_vertical_oscillation,
        'avg_leg_spring_stiffness': avg_leg_spring_stiffness,
        'left_right_balance': left_right_balance,
        'file_name': f'{activity_id}.fit',
        'source_type': 'garmin_oauth',
        'data_quality': 'high'
    }


def sync_user_zones_and_profile(
    db: Session,
    user_id: int,
    api: GarminConnectAPI
) -> None:
    """
    Sync HR zones, power zones, and athlete profile data from Garmin.
    
    Args:
        db: Database session
        user_id: User ID
        api: Authenticated Garmin API instance
    """
    try:
        user = crud.get_user_by_id(db, user_id)
        
        # Get user info (name, email, birthdate, etc)
        print("[ZONES] Fetching user profile...")
        try:
            profile_data = api.get_personal_record()
            print(f"[ZONES] Profile data: {profile_data}")
        except Exception as e:
            print(f"[ZONES] Could not fetch personal record: {e}")
            profile_data = {}
        
        # Try to get heart rate zones
        print("[ZONES] Fetching HR zones...")
        hr_zones = []
        try:
            # Garmin Connect API may have different methods for zones
            # Try multiple approaches
            try:
                # Method 1: Get settings
                settings = api.get_user_settings()
                if 'heartRateZones' in settings:
                    hr_zones = settings['heartRateZones']
            except:
                pass
            
            # Method 2: Calculate based on max HR if available
            if not hr_zones and user.max_heart_rate:
                max_hr = user.max_heart_rate
                hr_zones = [
                    {"zone": 1, "name": "Z1", "min": int(max_hr * 0.50), "max": int(max_hr * 0.60)},
                    {"zone": 2, "name": "Z2", "min": int(max_hr * 0.60), "max": int(max_hr * 0.70)},
                    {"zone": 3, "name": "Z3", "min": int(max_hr * 0.70), "max": int(max_hr * 0.80)},
                    {"zone": 4, "name": "Z4", "min": int(max_hr * 0.80), "max": int(max_hr * 0.90)},
                    {"zone": 5, "name": "Z5", "min": int(max_hr * 0.90), "max": int(max_hr * 1.00)},
                ]
                print(f"[ZONES] Calculated HR zones from max HR: {hr_zones}")
            
            if hr_zones:
                user.hr_zones = hr_zones
                print(f"[ZONES] HR zones saved: {len(hr_zones)} zones")
        except Exception as e:
            print(f"[ZONES] Error fetching HR zones: {e}")
        
        # Try to get power zones
        print("[ZONES] Fetching power zones...")
        power_zones = []
        try:
            # Power zones are typically trainer/power meter specific
            # Try to fetch from settings
            settings = api.get_user_settings()
            if 'powerZones' in settings:
                power_zones = settings['powerZones']
                print(f"[ZONES] Power zones found: {power_zones}")
        except Exception as e:
            print(f"[ZONES] Power zones not available: {e}")
        
        if power_zones:
            user.power_zones = power_zones
        
        db.commit()
        print("[ZONES] Profile sync completed")
        
    except Exception as e:
        print(f"[ZONES] Error syncing profile: {e}")


def sync_user_activities(
    db: Session,
    user_id: int,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None
) -> List[models.Workout]:
    """
    Sync activities from Garmin for a user.
    
    Args:
        db: Database session
        user_id: User ID
        start_date: Start date for sync (default: last 7 days, or 12 months if first sync)
        end_date: End date for sync (default: today)
        
    Returns:
        List of created Workout models
    """
    print(f"[SYNC] Starting sync for user {user_id}, dates: {start_date} to {end_date}")
    
    # Get user to check if first sync
    user = crud.get_user_by_id(db, user_id)
    is_first_sync = user.last_garmin_sync is None
    
    # Get Garmin API
    print("[SYNC] Calling get_user_garmin_api...")
    api = get_user_garmin_api(db, user_id)
    print("[SYNC] API obtained successfully")
    
    # Sync user profile, zones, and settings
    sync_user_zones_and_profile(db, user_id, api)
    
    # Default date range
    if not end_date:
        end_date = date.today()
    if not start_date:
        if is_first_sync:
            # First sync: get last 12 months
            start_date = end_date - timedelta(days=365)
            print(f"[SYNC] First sync detected - pulling 12 months of history")
        else:
            # Subsequent syncs: get last 7 days
            start_date = end_date - timedelta(days=7)
    
    # Fetch activities
    activities = api.get_activities_by_date(
        start_date.isoformat(),
        end_date.isoformat()
    )
    
    print(f"[SYNC] Found {len(activities)} activities from Garmin")
    
    created_workouts = []
    skipped_count = 0
    max_to_import = 300  # Safety limit
    
    for activity_dict in activities:
        # Stop if we reach 300 workouts
        if len(created_workouts) + skipped_count >= max_to_import:
            print(f"[SYNC] Reached max import limit of {max_to_import}")
            break
        
        activity_type = activity_dict.get('activityType', {}).get('typeKey', '')
        
        # Only process running activities
        if 'running' not in activity_type.lower():
            skipped_count += 1
            continue
        
        activity_id = str(activity_dict['activityId'])
        
        # Check if already exists
        existing = crud.get_workout_by_id(db, int(activity_id))
        if existing:
            skipped_count += 1
            continue
        
        try:
            # Download FIT file
            zip_data = api.download_activity(
                activity_id,
                dl_fmt=api.ActivityDownloadFormat.ORIGINAL
            )
            
            # Extract FIT from ZIP
            with zipfile.ZipFile(io.BytesIO(zip_data), 'r') as zip_ref:
                fit_filename = [name for name in zip_ref.namelist() if name.endswith('.fit')][0]
                with zip_ref.open(fit_filename) as fit_file:
                    fit_data = fit_file.read()
            
            # Parse FIT
            workout_data = parse_fit_file(fit_data, activity_id)
            
            # Create workout schema
            from ..schemas import WorkoutCreate
            workout_create = WorkoutCreate(**workout_data)
            
            # Save to database
            workout = crud.create_workout(db, user_id, workout_create)
            created_workouts.append(workout)
            
        except Exception as e:
            print(f"Error processing activity {activity_id}: {e}")
            skipped_count += 1
            continue
    
    # Update last_garmin_sync timestamp
    user.last_garmin_sync = datetime.utcnow()
    db.commit()
    
    print(f"[SYNC] Completed. Created: {len(created_workouts)}, Skipped: {skipped_count}")
    return created_workouts
