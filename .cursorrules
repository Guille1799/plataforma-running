# üéØ RunCoach AI - Instrucciones de Desarrollo

## Filosof√≠a de Trabajo

**Objetivo:** Excelencia y robustez m√°xima. Proyecto productivo perfecto.

### Principios Fundamentales

1. **C√≥digo de Producci√≥n**
   - Todo c√≥digo debe estar listo para producci√≥n
   - No dejar TODOs sin resolver
   - Manejo de errores exhaustivo
   - Validaci√≥n de datos en todas las capas
   - Logging apropiado para debugging

2. **Documentaci√≥n**
   - Documentaci√≥n siempre actualizada con el c√≥digo
   - Versiones exactas en toda la documentaci√≥n
   - Ejemplos de c√≥digo funcionales y probados
   - Comentarios claros en c√≥digo complejo

3. **Arquitectura**
   - Separaci√≥n clara de responsabilidades
   - C√≥digo reutilizable y modular
   - Type safety estricto (TypeScript)
   - Validaci√≥n de esquemas (Pydantic/Zod)

4. **Testing**
   - Tests para funcionalidades cr√≠ticas
   - Validaci√≥n manual antes de marcar como completo
   - Edge cases considerados

5. **Seguridad**
   - Nunca exponer secrets en c√≥digo
   - Validaci√≥n de inputs en backend
   - Sanitizaci√≥n de datos de usuario
   - Autenticaci√≥n JWT correctamente implementada

## üéì Metodolog√≠a de Explicaci√≥n

**CR√çTICO:** Siempre explicar qu√© se ha hecho y por qu√©, con DOS niveles:

### 1. Explicaci√≥n T√©cnica
- Para desarrolladores con experiencia
- Detalles de implementaci√≥n
- Decisiones t√©cnicas y alternativas consideradas
- Impacto en arquitectura y rendimiento

### 2. Explicaci√≥n para Dummies
- Lenguaje simple y claro
- Analog√≠as cuando sea √∫til
- Sin jerga t√©cnica innecesaria
- Enfocado en "qu√© hace" y "por qu√© importa"

### 3. Confirmaci√≥n antes de Continuar
- **NO pasar al siguiente paso hasta recibir OK expl√≠cito**
- Esperar confirmaci√≥n de que se entendi√≥
- Aclarar dudas antes de continuar
- Verificar que el usuario est√° listo para el siguiente cambio

### Ejemplo de Explicaci√≥n Dual:

**T√©cnico:**
"Implement√© un interceptor de Axios que maneja refresh tokens autom√°ticamente. Cuando detecta un 401, intercepta la respuesta, llama al endpoint `/auth/refresh` con el refresh token almacenado, actualiza el access token en memoria y localStorage, y reintenta la petici√≥n original. Esto mejora la UX al evitar que el usuario tenga que hacer login manualmente cuando expira el token."

**Para Dummies:**
"Cuando tu sesi√≥n expira (como cuando te desconectas de Netflix), en lugar de pedirte que vuelvas a iniciar sesi√≥n manualmente, el sistema autom√°ticamente renueva tu sesi√≥n en segundo plano y contin√∫a con lo que estabas haciendo. Es como tener un asistente que renueva tu pase sin que te des cuenta."

## üîÑ Flujo de Trabajo OBLIGATORIO

**‚ö†Ô∏è CR√çTICO: Este flujo debe seguirse estrictamente. Si el usuario se sale de este flujo, emitir un WARNING expl√≠cito.**

### Modo ASK (Preguntas y Consultas)
**USO EXCLUSIVO:**
- ‚úÖ Preguntas sobre el c√≥digo existente
- ‚úÖ Explicaciones de c√≥mo funciona algo
- ‚úÖ An√°lisis y revisi√≥n de c√≥digo (sin cambios)
- ‚úÖ Consultas de documentaci√≥n
- ‚úÖ Sugerencias y recomendaciones
- ‚úÖ Entender el contexto antes de planificar

**NO USAR para:**
- ‚ùå Hacer cambios en c√≥digo
- ‚ùå Crear archivos nuevos
- ‚ùå Ejecutar comandos
- ‚ùå Planificar features grandes

**EJEMPLOS CORRECTOS:**
```
‚úÖ "¬øC√≥mo funciona la autenticaci√≥n JWT en este proyecto?"
‚úÖ "Revisa este componente y dime si hay problemas"
‚úÖ "Expl√≠came el flujo de sincronizaci√≥n de Garmin"
‚úÖ "¬øQu√© mejoras necesita esta funci√≥n?"
‚úÖ "Analiza este c√≥digo y sugiere optimizaciones"
```

### Modo PLAN (Planificaci√≥n)
**USO EXCLUSIVO:**
- ‚úÖ Crear planes detallados para features grandes
- ‚úÖ Planificar refactorizaciones complejas
- ‚úÖ Dise√±ar arquitectura de nuevas funcionalidades
- ‚úÖ Dividir tareas en pasos ejecutables
- ‚úÖ Planificar migraciones o cambios estructurales

**NO USAR para:**
- ‚ùå Hacer preguntas simples
- ‚ùå Ejecutar c√≥digo o cambios
- ‚ùå Implementar directamente

**EJEMPLOS CORRECTOS:**
```
‚úÖ "Planifica la implementaci√≥n de notificaciones push"
‚úÖ "Crea un plan para refactorizar el sistema de autenticaci√≥n"
‚úÖ "Planifica la optimizaci√≥n de queries en la base de datos"
‚úÖ "Dise√±a un plan para migrar a TypeScript estricto"
```

**PROCESO:**
1. Analizar el c√≥digo actual y contexto
2. Crear plan paso a paso detallado
3. Explicar cada paso (t√©cnico + simple)
4. Esperar aprobaci√≥n del plan
5. **NO ejecutar el plan** - eso es trabajo de AGENT

### Modo AGENT (Ejecuci√≥n de C√≥digo y Cambios)
**USO EXCLUSIVO:**
- ‚úÖ Implementar c√≥digo seg√∫n un plan aprobado
- ‚úÖ Crear/editar/eliminar archivos
- ‚úÖ Refactorizar c√≥digo existente
- ‚úÖ Ejecutar comandos (git, npm, pip, etc.)
- ‚úÖ Aplicar fixes y correcciones
- ‚úÖ Implementar features completas

**NO USAR para:**
- ‚ùå Hacer preguntas
- ‚ùå Solo planificar sin implementar
- ‚ùå Consultas sin cambios

**EJEMPLOS CORRECTOS:**
```
‚úÖ "Implementa el endpoint POST /api/v1/workouts seg√∫n el plan aprobado"
‚úÖ "Crea el componente WorkoutCard con las especificaciones dadas"
‚úÖ "Refactoriza el servicio de autenticaci√≥n seg√∫n el plan paso 2"
‚úÖ "Aplica el fix para el bug de sincronizaci√≥n de Garmin"
‚úÖ "Crea los tests unitarios para el m√≥dulo de entrenamientos"
```

**REQUISITO:**
- AGENT solo debe ejecutar cuando hay un plan aprobado o instrucciones claras
- Si no hay plan, sugerir usar PLAN primero

### ‚ö†Ô∏è SISTEMA DE WARNINGS

**Si el usuario intenta usar un modo incorrecto, emitir este warning:**

```
‚ö†Ô∏è WARNING: Flujo de trabajo incorrecto detectado

Est√°s en modo [MODO_ACTUAL] pero est√°s intentando [ACCI√ìN_INCORRECTA].

Flujo correcto:
1. ASK ‚Üí Para preguntas y consultas
2. PLAN ‚Üí Para planificar features/cambios grandes
3. AGENT ‚Üí Para ejecutar c√≥digo y cambios

Acci√≥n sugerida:
[EXPLICAR QU√â MODO USAR Y POR QU√â]
```

**EJEMPLOS DE WARNINGS:**

Si en ASK piden crear c√≥digo:
```
‚ö†Ô∏è WARNING: Est√°s en modo ASK (solo consultas) pero intentas crear c√≥digo.

Para crear c√≥digo, debes:
1. Usar ASK primero: "¬øC√≥mo deber√≠a implementarse X?" o "Planifica Y"
2. Luego cambiar a PLAN: "Crea un plan detallado para implementar X"
3. Finalmente usar AGENT: "Implementa el plan paso 1"

¬øQuieres que cambie a modo PLAN primero?
```

Si en PLAN intentan ejecutar directamente:
```
‚ö†Ô∏è WARNING: Est√°s en modo PLAN (solo planificaci√≥n) pero intentas ejecutar c√≥digo.

El flujo correcto es:
1. PLAN ‚Üí Crear y aprobar el plan (‚úì Ya hecho)
2. AGENT ‚Üí Ejecutar el plan implementando el c√≥digo

¬øQuieres cambiar a modo AGENT para ejecutar el plan?
```

Si en AGENT piden solo preguntas:
```
‚ö†Ô∏è WARNING: Est√°s en modo AGENT (para ejecutar c√≥digo) pero solo haces una pregunta.

Para preguntas y consultas, usa modo ASK.

Para mantener el contexto, puedo:
- Responder aqu√≠, pero para futuras consultas usa ASK
- O cambiar a modo ASK para esta pregunta

¬øC√≥mo prefieres proceder?
```

## Stack Tecnol√≥gico (Versiones Exactas)

### Frontend
- **Next.js:** 16.0.3
- **React:** 19.2.0
- **TypeScript:** 5.x
- **Tailwind CSS:** 4.x
- **React Query:** 5.90.8
- **Zustand:** 5.0.8
- **Zod:** 4.1.12
- **Recharts:** 3.4.1

### Backend
- **Python:** 3.11+
- **FastAPI:** 0.121.1
- **SQLAlchemy:** 2.0.44
- **Pydantic:** 2.12.4
- **Celery:** 5.4.0
- **PostgreSQL:** 15
- **Redis:** 7

## Estructura del Proyecto

```
plataforma-running/
‚îú‚îÄ‚îÄ app/                    # Frontend Next.js (App Router)
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/            # Rutas de autenticaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/       # Rutas protegidas del dashboard
‚îÇ   ‚îî‚îÄ‚îÄ components/        # Componentes React
‚îú‚îÄ‚îÄ backend/               # API FastAPI
‚îÇ   ‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routers/       # Endpoints API
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/      # L√≥gica de negocio
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models.py      # Modelos SQLAlchemy
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ schemas.py     # Validaci√≥n Pydantic
‚îÇ   ‚îî‚îÄ‚îÄ tests/             # Tests del backend
‚îú‚îÄ‚îÄ components/            # Componentes compartidos
‚îú‚îÄ‚îÄ lib/                   # Utilidades y helpers
‚îú‚îÄ‚îÄ hooks/                 # React hooks personalizados
‚îú‚îÄ‚îÄ docs/                  # Documentaci√≥n actualizada
‚îÇ   ‚îú‚îÄ‚îÄ ARCHITECTURE.md
‚îÇ   ‚îú‚îÄ‚îÄ DEVELOPMENT.md
‚îÇ   ‚îú‚îÄ‚îÄ API.md
‚îÇ   ‚îî‚îÄ‚îÄ DEPLOYMENT.md
‚îî‚îÄ‚îÄ GUIAS_Y_EXPLICACIONES/ # Gu√≠as principales
```

## Convenciones de C√≥digo

### TypeScript/React
- Usar `interface` para tipos de objetos
- Componentes funcionales con TypeScript
- Props tipadas expl√≠citamente
- Manejo de errores con try/catch y estados de error
- Loading states siempre presentes

### Python/FastAPI
- Type hints en todas las funciones
- Docstrings en funciones p√∫blicas
- Validaci√≥n con Pydantic schemas
- Manejo de excepciones espec√≠ficas
- Logging estructurado

### Nombres
- Variables: camelCase (TS) / snake_case (Python)
- Componentes: PascalCase
- Archivos: kebab-case para componentes, camelCase para utilidades
- Constantes: UPPER_SNAKE_CASE

## Flujo de Trabajo Est√°ndar

### Para Features Nuevas:
```
1. ASK ‚Üí "¬øC√≥mo funciona X actualmente?" (entender contexto)
2. ASK ‚Üí "¬øQu√© necesitamos para implementar Y?" (requisitos)
3. PLAN ‚Üí "Crea un plan detallado para implementar Y"
4. Revisar y aprobar plan
5. AGENT ‚Üí "Implementa el plan paso 1"
6. Revisar c√≥digo generado
7. AGENT ‚Üí "Contin√∫a con el paso 2" (repetir hasta completar)
8. ASK ‚Üí "Revisa el c√≥digo final y sugiere mejoras"
```

### Para Bugs:
```
1. ASK ‚Üí "Investiga este error: [descripci√≥n]"
2. ASK ‚Üí "¬øCu√°l es la causa ra√≠z y c√≥mo se soluciona?"
3. PLAN ‚Üí "Crea un plan para arreglar el bug"
4. AGENT ‚Üí "Implementa la soluci√≥n seg√∫n el plan"
5. ASK ‚Üí "Verifica que la soluci√≥n es correcta"
```

### Para Refactorizaciones:
```
1. ASK ‚Üí "Analiza este c√≥digo y sugiere mejoras"
2. PLAN ‚Üí "Crea un plan de refactorizaci√≥n"
3. AGENT ‚Üí "Ejecuta el plan de refactorizaci√≥n"
4. ASK ‚Üí "Revisa el c√≥digo refactorizado"
```

## Documentaci√≥n

- **Siempre actualizar** cuando cambies c√≥digo
- **Versiones exactas** en toda la documentaci√≥n
- **Ejemplos funcionales** que se puedan copiar y pegar
- **Diagramas ASCII** para arquitectura cuando sea √∫til

## Errores Comunes a Evitar

1. ‚ùå Dejar versiones incorrectas en documentaci√≥n
2. ‚ùå C√≥digo sin manejo de errores
3. ‚ùå TODOs sin resolver
4. ‚ùå Validaci√≥n solo en frontend
5. ‚ùå Secrets hardcodeados
6. ‚ùå C√≥digo comentado sin explicaci√≥n
7. ‚ùå Funciones sin type hints/types
8. ‚ùå Continuar sin confirmaci√≥n del usuario
9. ‚ùå **Usar modo incorrecto para la tarea**
10. ‚ùå **Intentar ejecutar c√≥digo en modo ASK o PLAN**

## Checklist de Calidad

Antes de marcar algo como completo:

- [ ] C√≥digo funciona correctamente
- [ ] Manejo de errores implementado
- [ ] Validaci√≥n de datos presente
- [ ] Type safety completo
- [ ] Documentaci√≥n actualizada
- [ ] Versiones correctas en docs
- [ ] Sin TODOs pendientes
- [ ] Edge cases considerados
- [ ] Logging apropiado
- [ ] C√≥digo limpio y legible
- [ ] Explicaci√≥n t√©cnica proporcionada
- [ ] Explicaci√≥n simple proporcionada
- [ ] Confirmaci√≥n del usuario recibida
- [ ] **Flujo de trabajo correcto seguido (ASK ‚Üí PLAN ‚Üí AGENT)**
- [ ] **Coordinaci√≥n con otros agents verificada (si aplica)**

## ü§ù COORDINACI√ìN M√öLTIPLE DE AGENTS

**‚ö†Ô∏è CR√çTICO: Si hay m√∫ltiples agents trabajando simult√°neamente, SIEMPRE seguir este protocolo.**

### Sistema de Coordinaci√≥n Permanente

**‚ö†Ô∏è LECTURA OBLIGATORIA:**
1. **SIEMPRE leer `scripts/agent-coordination.md`** antes de trabajar con m√∫ltiples agents
2. Este archivo contiene la gu√≠a completa y ejemplos detallados
3. Consultarlo para dividir tareas, entender protocolos y resolver dudas

**Archivos del Sistema:**
- `.agent-lock.json` - Estado compartido de locks y tareas (leer ANTES de cada edici√≥n)
- `scripts/agent-coordination.md` - Gu√≠a detallada de uso (leer AL INICIO del trabajo conjunto)

**Este sistema es PERMANENTE y funciona para:**
- ‚úÖ Cualquier plan (no solo el plan actual)
- ‚úÖ Cualquier tarea (refactoring, features, bugs, etc.)
- ‚úÖ Cualquier n√∫mero de agents (2, 3, 4+)
- ‚úÖ Trabajo simult√°neo permanente

### Protocolo OBLIGATORIO Antes de Editar Archivos

**PASO 0: Leer Documentaci√≥n (SIEMPRE)**
1. Leer `scripts/agent-coordination.md` para entender el protocolo completo
2. Leer `.agent-lock.json` para verificar estado actual de otros agents
3. Identificar tu agent ID (agent-1, agent-2, etc.) seg√∫n el contexto

**PASO 1: Verificar Locks (SIEMPRE)**
1. Leer `.agent-lock.json` antes de editar CUALQUIER archivo
2. Verificar que el archivo NO est√© en `files_being_edited` de otro agent
3. Si est√° siendo editado, ESPERAR o elegir otro archivo/tarea
4. Consultar `scripts/agent-coordination.md` si hay dudas sobre divisi√≥n de trabajo

**PASO 2: Reservar Archivo (SIEMPRE)**
1. Agregar el archivo a TU `files_being_edited` en `.agent-lock.json`
2. Actualizar `last_update` con timestamp actual (formato ISO: `YYYY-MM-DDTHH:MM:SSZ`)
3. Guardar el archivo INMEDIATAMENTE
4. Si otro agent est√° editando el mismo archivo, DETENER y elegir otro archivo

**PASO 3: Editar Archivo**
1. Realizar los cambios normalmente
2. Verificar que funciona (lint, tests si aplica)

**PASO 4: Liberar Lock (SIEMPRE)**
1. Remover el archivo de TU `files_being_edited`
2. Agregar a `tasks_completed` si la tarea est√° completa
3. Actualizar `last_update` con timestamp actual
4. Guardar el archivo INMEDIATAMENTE

### Divisi√≥n de Trabajo Recomendada

**Cuando trabajan m√∫ltiples agents, dividir por:**
- **M√≥dulos/Archivos:** Agent 1 edita routers, Agent 2 edita services
- **Tareas independientes:** Agent 1 hace refactoring, Agent 2 resuelve bugs
- **√Åreas funcionales:** Agent 1 frontend, Agent 2 backend

**NUNCA trabajar simult√°neamente en:**
- El mismo archivo
- Archivos que dependen directamente (ej: router y su dependency)
- Mismos modelos/base de datos (sin coordinaci√≥n expl√≠cita)

### Comunicaci√≥n entre Agents

**‚ùå NO es posible comunicarse directamente entre agents** (cada agent ejecuta en su propio contexto aislado).

**‚úÖ SOLUCI√ìN: Sistema de Locks (`.agent-lock.json`)**
- Estado compartido actualizado en tiempo real
- Todos los agents leen/escriben el mismo archivo
- Previene conflictos autom√°ticamente

**Formato del Lock:**
```json
{
  "agents": {
    "agent-1": {
      "status": "active",
      "current_task": "Descripci√≥n de tarea",
      "files_being_edited": ["ruta/archivo1.py", "ruta/archivo2.ts"],
      "tasks_completed": ["task-id-1", "task-id-2"],
      "tasks_in_progress": ["task-id-3"]
    }
  },
  "last_update": "2025-01-27T12:00:00Z"
}
```

### Reglas de Coordinaci√≥n

1. **SIEMPRE leer `.agent-lock.json` antes de editar**
2. **SIEMPRE actualizar `.agent-lock.json` al reservar/liberar**
3. **NO editar archivos en `files_being_edited` de otro agent**
4. **Actualizar `last_update` en cada cambio del lock**
5. **Mantener `tasks_in_progress` y `tasks_completed` actualizados**

### Ejemplo de Uso

**Agent 1 quiere editar `backend/app/routers/workouts.py`:**

```json
// ANTES: Leer .agent-lock.json
{
  "agents": {
    "agent-2": {
      "files_being_edited": ["backend/app/services/coach_service.py"]
    }
  }
}

// ‚úÖ workouts.py NO est√° en lista de agent-2 ‚Üí PUEDE EDITAR

// DURANTE: Reservar el archivo
{
  "agents": {
    "agent-1": {
      "files_being_edited": ["backend/app/routers/workouts.py"]
    },
    "agent-2": {
      "files_being_edited": ["backend/app/services/coach_service.py"]
    }
  },
  "last_update": "2025-01-27T12:05:00Z"
}

// DESPU√âS: Liberar el lock
{
  "agents": {
    "agent-1": {
      "files_being_edited": [],
      "tasks_completed": ["code-centralize-auth-workouts"]
    }
  },
  "last_update": "2025-01-27T12:10:00Z"
}
```

### Cuando NO Hay Otro Agent Activo

- Si `.agent-lock.json` muestra `agent-2.status: "inactive"` o no existe
- Puedes trabajar normalmente sin actualizar locks
- Pero SIEMPRE verificar primero por si acaso

### Manejo de Conflictos

**Si detectas que otro agent est√° editando el mismo archivo:**
1. **DETENER** inmediatamente tus cambios
2. **COMUNICAR** al usuario del conflicto
3. **ESPERAR** a que el otro agent termine o **ELEGIR** otro archivo/tarea
4. **COORDINAR** con el usuario para dividir trabajo diferente

### Integraci√≥n con Planes

**Cuando se ejecuta un plan con m√∫ltiples agents:**
1. **Leer `scripts/agent-coordination.md`** antes de empezar el plan
2. El plan debe incluir divisi√≥n clara de tareas por agent
3. Acordar divisi√≥n de trabajo con el usuario si es necesario
4. Actualizar `.agent-lock.json` con la divisi√≥n acordada
5. Cada agent debe actualizar `.agent-lock.json` con sus tareas asignadas conforme avanza
6. Coordinar por m√≥dulos/archivos, no por features completas
7. El sistema funciona para cualquier plan, no solo el actual

**Ejemplo de Divisi√≥n para un Plan:**
- Agent 1: Routers principales (workouts, events, coach, training_plans)
- Agent 2: Routers secundarios (health, profile, onboarding, etc.)
- O dividir por tareas: Agent 1 hace refactoring, Agent 2 resuelve bugs