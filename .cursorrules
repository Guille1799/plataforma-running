# ğŸ¯ RunCoach AI - Instrucciones de Desarrollo

## FilosofÃ­a de Trabajo

**Objetivo:** Excelencia y robustez mÃ¡xima. Proyecto productivo perfecto.

### Principios Fundamentales

1. **CÃ³digo de ProducciÃ³n**
   - Todo cÃ³digo debe estar listo para producciÃ³n
   - No dejar TODOs sin resolver
   - Manejo de errores exhaustivo
   - ValidaciÃ³n de datos en todas las capas
   - Logging apropiado para debugging

2. **DocumentaciÃ³n**
   - DocumentaciÃ³n siempre actualizada con el cÃ³digo
   - Versiones exactas en toda la documentaciÃ³n
   - Ejemplos de cÃ³digo funcionales y probados
   - Comentarios claros en cÃ³digo complejo

3. **Arquitectura**
   - SeparaciÃ³n clara de responsabilidades
   - CÃ³digo reutilizable y modular
   - Type safety estricto (TypeScript)
   - ValidaciÃ³n de esquemas (Pydantic/Zod)

4. **Testing**
   - Tests para funcionalidades crÃ­ticas
   - ValidaciÃ³n manual antes de marcar como completo
   - Edge cases considerados

5. **Seguridad**
   - Nunca exponer secrets en cÃ³digo
   - ValidaciÃ³n de inputs en backend
   - SanitizaciÃ³n de datos de usuario
   - AutenticaciÃ³n JWT correctamente implementada

## ğŸ“ MetodologÃ­a de ExplicaciÃ³n

**CRÃTICO:** Siempre explicar quÃ© se ha hecho y por quÃ©, con DOS niveles:

### 1. ExplicaciÃ³n TÃ©cnica
- Para desarrolladores con experiencia
- Detalles de implementaciÃ³n
- Decisiones tÃ©cnicas y alternativas consideradas
- Impacto en arquitectura y rendimiento

### 2. ExplicaciÃ³n para Dummies
- Lenguaje simple y claro
- AnalogÃ­as cuando sea Ãºtil
- Sin jerga tÃ©cnica innecesaria
- Enfocado en "quÃ© hace" y "por quÃ© importa"

### 3. ConfirmaciÃ³n antes de Continuar
- **NO pasar al siguiente paso hasta recibir OK explÃ­cito**
- Esperar confirmaciÃ³n de que se entendiÃ³
- Aclarar dudas antes de continuar
- Verificar que el usuario estÃ¡ listo para el siguiente cambio

### Ejemplo de ExplicaciÃ³n Dual:

**TÃ©cnico:**
"ImplementÃ© un interceptor de Axios que maneja refresh tokens automÃ¡ticamente. Cuando detecta un 401, intercepta la respuesta, llama al endpoint `/auth/refresh` con el refresh token almacenado, actualiza el access token en memoria y localStorage, y reintenta la peticiÃ³n original. Esto mejora la UX al evitar que el usuario tenga que hacer login manualmente cuando expira el token."

**Para Dummies:**
"Cuando tu sesiÃ³n expira (como cuando te desconectas de Netflix), en lugar de pedirte que vuelvas a iniciar sesiÃ³n manualmente, el sistema automÃ¡ticamente renueva tu sesiÃ³n en segundo plano y continÃºa con lo que estabas haciendo. Es como tener un asistente que renueva tu pase sin que te des cuenta."

## ğŸ”„ Flujo de Trabajo OBLIGATORIO

**âš ï¸ CRÃTICO: Este flujo debe seguirse estrictamente. Si el usuario se sale de este flujo, emitir un WARNING explÃ­cito.**

### Modo ASK (Preguntas y Consultas)
**USO EXCLUSIVO:**
- âœ… Preguntas sobre el cÃ³digo existente
- âœ… Explicaciones de cÃ³mo funciona algo
- âœ… AnÃ¡lisis y revisiÃ³n de cÃ³digo (sin cambios)
- âœ… Consultas de documentaciÃ³n
- âœ… Sugerencias y recomendaciones
- âœ… Entender el contexto antes de planificar

**NO USAR para:**
- âŒ Hacer cambios en cÃ³digo
- âŒ Crear archivos nuevos
- âŒ Ejecutar comandos
- âŒ Planificar features grandes

**EJEMPLOS CORRECTOS:**
```
âœ… "Â¿CÃ³mo funciona la autenticaciÃ³n JWT en este proyecto?"
âœ… "Revisa este componente y dime si hay problemas"
âœ… "ExplÃ­came el flujo de sincronizaciÃ³n de Garmin"
âœ… "Â¿QuÃ© mejoras necesita esta funciÃ³n?"
âœ… "Analiza este cÃ³digo y sugiere optimizaciones"
```

### Modo PLAN (PlanificaciÃ³n)
**USO EXCLUSIVO:**
- âœ… Crear planes detallados para features grandes
- âœ… Planificar refactorizaciones complejas
- âœ… DiseÃ±ar arquitectura de nuevas funcionalidades
- âœ… Dividir tareas en pasos ejecutables
- âœ… Planificar migraciones o cambios estructurales

**NO USAR para:**
- âŒ Hacer preguntas simples
- âŒ Ejecutar cÃ³digo o cambios
- âŒ Implementar directamente

**EJEMPLOS CORRECTOS:**
```
âœ… "Planifica la implementaciÃ³n de notificaciones push"
âœ… "Crea un plan para refactorizar el sistema de autenticaciÃ³n"
âœ… "Planifica la optimizaciÃ³n de queries en la base de datos"
âœ… "DiseÃ±a un plan para migrar a TypeScript estricto"
```

**PROCESO:**
1. Analizar el cÃ³digo actual y contexto
2. Crear plan paso a paso detallado
3. Explicar cada paso (tÃ©cnico + simple)
4. Esperar aprobaciÃ³n del plan
5. **NO ejecutar el plan** - eso es trabajo de AGENT

### Modo AGENT (EjecuciÃ³n de CÃ³digo y Cambios)
**USO EXCLUSIVO:**
- âœ… Implementar cÃ³digo segÃºn un plan aprobado
- âœ… Crear/editar/eliminar archivos
- âœ… Refactorizar cÃ³digo existente
- âœ… Ejecutar comandos (git, npm, pip, etc.)
- âœ… Aplicar fixes y correcciones
- âœ… Implementar features completas

**NO USAR para:**
- âŒ Hacer preguntas
- âŒ Solo planificar sin implementar
- âŒ Consultas sin cambios

**EJEMPLOS CORRECTOS:**
```
âœ… "Implementa el endpoint POST /api/v1/workouts segÃºn el plan aprobado"
âœ… "Crea el componente WorkoutCard con las especificaciones dadas"
âœ… "Refactoriza el servicio de autenticaciÃ³n segÃºn el plan paso 2"
âœ… "Aplica el fix para el bug de sincronizaciÃ³n de Garmin"
âœ… "Crea los tests unitarios para el mÃ³dulo de entrenamientos"
```

**REQUISITO:**
- AGENT solo debe ejecutar cuando hay un plan aprobado o instrucciones claras
- Si no hay plan, sugerir usar PLAN primero

### âš ï¸ SISTEMA DE WARNINGS

**Si el usuario intenta usar un modo incorrecto, emitir este warning:**

```
âš ï¸ WARNING: Flujo de trabajo incorrecto detectado

EstÃ¡s en modo [MODO_ACTUAL] pero estÃ¡s intentando [ACCIÃ“N_INCORRECTA].

Flujo correcto:
1. ASK â†’ Para preguntas y consultas
2. PLAN â†’ Para planificar features/cambios grandes
3. AGENT â†’ Para ejecutar cÃ³digo y cambios

AcciÃ³n sugerida:
[EXPLICAR QUÃ‰ MODO USAR Y POR QUÃ‰]
```

**EJEMPLOS DE WARNINGS:**

Si en ASK piden crear cÃ³digo:
```
âš ï¸ WARNING: EstÃ¡s en modo ASK (solo consultas) pero intentas crear cÃ³digo.

Para crear cÃ³digo, debes:
1. Usar ASK primero: "Â¿CÃ³mo deberÃ­a implementarse X?" o "Planifica Y"
2. Luego cambiar a PLAN: "Crea un plan detallado para implementar X"
3. Finalmente usar AGENT: "Implementa el plan paso 1"

Â¿Quieres que cambie a modo PLAN primero?
```

Si en PLAN intentan ejecutar directamente:
```
âš ï¸ WARNING: EstÃ¡s en modo PLAN (solo planificaciÃ³n) pero intentas ejecutar cÃ³digo.

El flujo correcto es:
1. PLAN â†’ Crear y aprobar el plan (âœ“ Ya hecho)
2. AGENT â†’ Ejecutar el plan implementando el cÃ³digo

Â¿Quieres cambiar a modo AGENT para ejecutar el plan?
```

Si en AGENT piden solo preguntas:
```
âš ï¸ WARNING: EstÃ¡s en modo AGENT (para ejecutar cÃ³digo) pero solo haces una pregunta.

Para preguntas y consultas, usa modo ASK.

Para mantener el contexto, puedo:
- Responder aquÃ­, pero para futuras consultas usa ASK
- O cambiar a modo ASK para esta pregunta

Â¿CÃ³mo prefieres proceder?
```

## Stack TecnolÃ³gico (Versiones Exactas)

### Frontend
- **Next.js:** 16.0.3
- **React:** 19.2.0
- **TypeScript:** 5.x
- **Tailwind CSS:** 4.x
- **React Query:** 5.90.8
- **Zustand:** 5.0.8
- **Zod:** 4.1.12
- **Recharts:** 3.4.1

### Backend
- **Python:** 3.11+
- **FastAPI:** 0.121.1
- **SQLAlchemy:** 2.0.44
- **Pydantic:** 2.12.4
- **Celery:** 5.4.0
- **PostgreSQL:** 15
- **Redis:** 7

## Estructura del Proyecto

```
plataforma-running/
â”œâ”€â”€ app/                    # Frontend Next.js (App Router)
â”‚   â”œâ”€â”€ (auth)/            # Rutas de autenticaciÃ³n
â”‚   â”œâ”€â”€ (dashboard)/       # Rutas protegidas del dashboard
â”‚   â””â”€â”€ components/        # Componentes React
â”œâ”€â”€ backend/               # API FastAPI
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ routers/       # Endpoints API
â”‚   â”‚   â”œâ”€â”€ services/      # LÃ³gica de negocio
â”‚   â”‚   â”œâ”€â”€ models.py      # Modelos SQLAlchemy
â”‚   â”‚   â””â”€â”€ schemas.py     # ValidaciÃ³n Pydantic
â”‚   â””â”€â”€ tests/             # Tests del backend
â”œâ”€â”€ components/            # Componentes compartidos
â”œâ”€â”€ lib/                   # Utilidades y helpers
â”œâ”€â”€ hooks/                 # React hooks personalizados
â”œâ”€â”€ docs/                  # DocumentaciÃ³n actualizada
â”‚   â”œâ”€â”€ ARCHITECTURE.md
â”‚   â”œâ”€â”€ DEVELOPMENT.md
â”‚   â”œâ”€â”€ API.md
â”‚   â””â”€â”€ DEPLOYMENT.md
â””â”€â”€ GUIAS_Y_EXPLICACIONES/ # GuÃ­as principales
```

## Convenciones de CÃ³digo

### TypeScript/React
- Usar `interface` para tipos de objetos
- Componentes funcionales con TypeScript
- Props tipadas explÃ­citamente
- Manejo de errores con try/catch y estados de error
- Loading states siempre presentes

### Python/FastAPI
- Type hints en todas las funciones
- Docstrings en funciones pÃºblicas
- ValidaciÃ³n con Pydantic schemas
- Manejo de excepciones especÃ­ficas
- Logging estructurado

### Nombres
- Variables: camelCase (TS) / snake_case (Python)
- Componentes: PascalCase
- Archivos: kebab-case para componentes, camelCase para utilidades
- Constantes: UPPER_SNAKE_CASE

## Flujo de Trabajo EstÃ¡ndar

### Para Features Nuevas:
```
1. ASK â†’ "Â¿CÃ³mo funciona X actualmente?" (entender contexto)
2. ASK â†’ "Â¿QuÃ© necesitamos para implementar Y?" (requisitos)
3. PLAN â†’ "Crea un plan detallado para implementar Y"
4. Revisar y aprobar plan
5. AGENT â†’ "Implementa el plan paso 1"
6. Revisar cÃ³digo generado
7. AGENT â†’ "ContinÃºa con el paso 2" (repetir hasta completar)
8. ASK â†’ "Revisa el cÃ³digo final y sugiere mejoras"
```

### Para Bugs:
```
1. ASK â†’ "Investiga este error: [descripciÃ³n]"
2. ASK â†’ "Â¿CuÃ¡l es la causa raÃ­z y cÃ³mo se soluciona?"
3. PLAN â†’ "Crea un plan para arreglar el bug"
4. AGENT â†’ "Implementa la soluciÃ³n segÃºn el plan"
5. ASK â†’ "Verifica que la soluciÃ³n es correcta"
```

### Para Refactorizaciones:
```
1. ASK â†’ "Analiza este cÃ³digo y sugiere mejoras"
2. PLAN â†’ "Crea un plan de refactorizaciÃ³n"
3. AGENT â†’ "Ejecuta el plan de refactorizaciÃ³n"
4. ASK â†’ "Revisa el cÃ³digo refactorizado"
```

## DocumentaciÃ³n

- **Siempre actualizar** cuando cambies cÃ³digo
- **Versiones exactas** en toda la documentaciÃ³n
- **Ejemplos funcionales** que se puedan copiar y pegar
- **Diagramas ASCII** para arquitectura cuando sea Ãºtil

## Errores Comunes a Evitar

1. âŒ Dejar versiones incorrectas en documentaciÃ³n
2. âŒ CÃ³digo sin manejo de errores
3. âŒ TODOs sin resolver
4. âŒ ValidaciÃ³n solo en frontend
5. âŒ Secrets hardcodeados
6. âŒ CÃ³digo comentado sin explicaciÃ³n
7. âŒ Funciones sin type hints/types
8. âŒ Continuar sin confirmaciÃ³n del usuario
9. âŒ **Usar modo incorrecto para la tarea**
10. âŒ **Intentar ejecutar cÃ³digo en modo ASK o PLAN**

## Checklist de Calidad

Antes de marcar algo como completo:

- [ ] CÃ³digo funciona correctamente
- [ ] Manejo de errores implementado
- [ ] ValidaciÃ³n de datos presente
- [ ] Type safety completo
- [ ] DocumentaciÃ³n actualizada
- [ ] Versiones correctas en docs
- [ ] Sin TODOs pendientes
- [ ] Edge cases considerados
- [ ] Logging apropiado
- [ ] CÃ³digo limpio y legible
- [ ] ExplicaciÃ³n tÃ©cnica proporcionada
- [ ] ExplicaciÃ³n simple proporcionada
- [ ] ConfirmaciÃ³n del usuario recibida
- [ ] **Flujo de trabajo correcto seguido (ASK â†’ PLAN â†’ AGENT)**
